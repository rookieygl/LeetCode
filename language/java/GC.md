# 垃圾回收
Hotspot（oracle官方虚拟机）
# 垃圾回收器
除了G1和ZGC，旧版的GC回收器都需要组合使用
1. Serial/Serial Old：单线程垃圾回收器。会Stop World
2. Parallel Scavenge/Parallel Old:并行垃圾回收器。Stop World时间比单线程较短
3. ParNew/CMS:cms垃圾回收器，并行标记，Stop World清除垃圾。比Parallel 暂停较短

**以上的jdk1.7之前的垃圾回收器，都需要配置JVM，针对新生代和老年代组合使用 JDK 7u4推出G1，Java 11推出ZGC**
4. G1（Garbage First）：逻辑分区，物理不分区，追求停顿时间
5. ZGC：逻辑不分区，物理不分区

# 标记垃圾
## 引用计数法
被引用一次，计数器加1，为0标记为垃圾。无法解决循环依赖。两个空对象互相引用，计数都为1，导致无法回收。

## 可达性分析
从GC Roots对象开始寻找引用链，不在引用链的标记为垃圾。
可以作为GC Roots节点的对象有
1. 虚拟机栈中引用的对象（栈帧中的本地变量表）
2. 方法区中类静态属性引用的对象；根据这条规则，单例也可以作为根对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI（Native方法）引用的对象

### 三色标记
白，灰，黑三种类型
1. 白色：尚未访问过。
2. 黑色：本对象已访问过，而且本对象 引用到 的其他对象 也全部访问过了。
3. 灰色：本对象已访问过，但是本对象 引用到 的其他对象 尚未全部访问完。全部访问后，会转换为黑色
#### 标记步骤
1. 初始都是白色
2. 可用的放到灰色集合
3. 整理灰色的
    1. 将本对象 引用到的 其他对象 全部挪到灰色集合中
    2. 将本对象 挪到黑色集合里面
4. 重复步骤三
5. 仍在白色集合的对象即为GC Roots不可达，可以进行回收
第四部的重复可以解释G1的暂停时间MaxGCPauseMillis并不准确

### 多标（重标）-浮动垃圾
对性能和正确性影响不大，第二次GC会回收
1. 链路断裂
    灰色集合D->E->F ，D标记黑色后DE断开，
    本次回收E会被当做浮动的根节点，EF下次不可达才会回收
2. 新生代对象
    针对并发标记开始后的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。
    这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分
    
    
### 漏标
影响正确性，不可接受
#### 漏标
```java
Object F = objE.fieldF; // 1.读
objE.fieldf = null;  // 2.写
objD.fieldF = F;     // 3.写
```
D->E->F 标记D黑色后F为灰色，但是EF断裂，D指向F，但是D为黑色，F不再重新标记，F会被回收
#### 触发条件
1. 灰色对象断开了白色对象的引用；即灰色对象 原来成员变量的引用发生了变化。
2. 黑色对象重新引用了该白色对象；即黑色对象 成员变量增加了新的引用。
#### 解决漏标-读写屏障
只研究G1的写屏障
#### G1：写屏障 + SATB
当对象变化时，记录下原来的引用对象
这种做法的思路是：尝试保留开始时的对象图，即原始快照（Snapshot At The Beginning，SATB），
当某个时刻的GC Roots确定后，当时的对象图就已经确定了
```java
void pre_write_barrier(Object field) {
    Object old_value = field; //保存值
    remark_set.add(old_value); //记录原来的引用对象，下次可以直接查找
}
```
SATB破坏了条件一，灰色断开，保留白色集合，需要额外内存
1. remark_set需要内存，但是只记录灰色断开的，可以接受
2. 不是并发标记阶段就不用记录，并且set可以去重

#### ZGC：读屏障
```java
oop oop_field_load(Object field) {
    pre_load_barrier(field); // 读屏障-读取前操作
    return field;
}

void pre_load_barrier(Object field, oop old_value) {  
  if(gc_phase == GC_CONCURRENT_MARK && !isMarkd(field)) {
      Object old_value = field;
      remark_set.add(old_value); // 记录读取到的对象
  }
}
```
读屏障是直接针对第一步：Object F = objE.fieldF; 当读取成员变量时，一律记录下来，
就是记录所有的引用成员

这种做法是保守的，但也是安全的。因为条件二中黑色对象重新引用了该白色对象
重新引用的前提是：得获取到该白色对象，此时已经读屏障就发挥作用了
#### CMS：写屏障 + 增量更新
增量不保存旧地址，有ABA问题，即是放弃后重新引用，会是同一个，但是引用了B，B就会漏
# 垃圾清除算法
只有这三种算法，各有优缺点，垃圾回收器会采用多个清除算法进行工作。
1. 复制算法：复制到另一端，需要双倍内存。适合内存小的区域（新生代）
2. 标记清除：空间不连续。
3. 标记整理：最优解。标记后移动到一端，整理内存后清理。

# 三种GC过程
1. Young GC 新生代
2. Mixed GC 混合回收
3. Full GC 全局GC

## Young GC Minor GC
新生代分为：Eden，Survivor （Survivor0，Survivor1）
Eden是最大的区域，因此有个针对Eden的回收过程，称为 Young GC,也叫 Minor GC。

Young GC是在新生代的Eden区域满了之后就会触发，数据量较小，一般采用复制算法来回收新生代的垃圾
**停止-复制（Stop-and-copy）清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中）**

### 触发条件
Young GC一直在运行，大部分对象创建后，很快不再使用。Eden满了，也会触发Young GC，大对象会被直接创建在老年代
### Young GC回收过程
1. 首先会把Ened区与ServivorFrom区中存活的对象复制到ServivorTo区中去
    1. 整体对象的标准年龄+1,到15就会移动到老年代，
    2. 如果ServivorTo的内存不足的情况，存活的对象就直接全部复制到老年代
2. 清空Ened区与ServivorFrom区
3. 将ServivorTo区与ServivorFrom区互换，原本的ServivorTo区成为了下一次ServivorFrom区，
    然后下一次他里面的对象又要被复制到下一次的ServivorTo区中区



## Full GC Major GC
1. Full GC：收集young gen、old gen、perm gen
2. Major GC：有时又叫old gc，只收集old gen
### 触发条件
1. 发生Young GC之前进行检查，如果老年代可用的连续内存空间小于Young GC后升入老年代的对象总和的平均大小，
    老年代空间不够，此时必须先触发一次Old GC，再执行Young GC
2. 老年代内存使用率超过了92%，也要直接触发Old GC，当然这个比例是可以通过参数调整的
3. 调用System.gc时,但是不立刻必然执行
### 回收过程

# G1
G1（Garbage-First）优先回收内存占用最高，对象占用最大的区域，不保证全部回收但是速度快

G1一视同仁，对新生代老年代永久代使用同一种回收方式
## 停顿次数
G1 停顿三次 停顿很短
1. 初始标记 暂停
2. 根区域扫描
3. 并发标记
4. 重新标记 暂停
5. 独占清理 暂停
6. 并发清理阶段

## 实现原理
1. 分区（Region）
  依旧有老年代和新生代，不过被分散在棋盘格式的相等的内存块里。每个分区都可能是年轻代也可能是老年代，
  但是在同一时刻只能属于某个代。也就是逻辑分区，物理不分区。
  Region大小一致，数值是在 1M 到 32M 字节之间的一个2的幂值数，JVM会尽量划分2048个左右、同等大小的 region。
  当然这个数字既可以手动调整，G1 也会根据堆大小自动进行调整。
2. 收集集合（CSet）
  一组可被回收的分区的集合。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，
  CSet中的分区可以来自Eden空间、survivor空间、或者老年代。
  CSet会占用不到整个堆空间的1%大小。
3. 已记忆集合（RSet）
  RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。
  RSet的价值在于使得垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可
    

## 优点
1. Eden、Survivor、Old区不再固定，在内存使用效率上来说更灵活，减少磁盘碎片。
    假若通过-Xmn显式地指定了年轻代的大小, 则会干扰到G1收集器的默认行为.
2. G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间，避免应用雪崩现象。
3. G1在回收内存后会马上同时做合并空闲内存的工作，而CMS默认是在STW(stop the world)的时候做。
4. G1会在young GC中使用，而CMS只能在老年代中使用。
5. G1是棋盘格局，**标记-整理**方式清除垃圾，压缩空间方面有优势。

## 缺点
1. Region棋盘格局导致大小对象占用的格子是一样的，导致空间分配不均匀，并且，region 太小不合适，
会令你在分配大对象时更难找到连续空间。

## G1 Mixed GC
混合回收就是把老年代的一些区域加在将要回收的Eden和Servivor的后面，
这些所有将要回收的区域叫做Collection Set（CSet），最后用年轻代回收算法一起回收

## 解决碎片
G1是一种服务端应用使用的压缩垃圾收集器，目标是用在多核、大内存的机器上，它在大多数情况下可以实现指定的GC暂停时间，同时还能保持较高的吞吐量。

## G1核心参数

| 参数名称                             | 含义                                                         | 默认值                 |
| ------------------------------------ | ------------------------------------------------------------ | ---------------------- |
| -XX:+UseG1GC                         | 开启G1垃圾收集器                                             |                        |
| -XX:MaxGCPauseMillis=200             | 设置期望达到的最大GC停顿时间指标（毫秒单位，JVM会尽力实现，但不保证达到），值越低，cpu占用率越高。 | 200                    |
| XX:InitiatingHeapOccupancyPercent=45 | 堆内存占用百分比，G1用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比. 值为0，表示一直gc | 45                     |
| -XX:NewRatio=n                       | 新生代与老生代的大小比例，不允许值小于1，即Old要比Yong大     | 2：新生代：老年代：1:2 |
| -XX:MaxTenuringThreshold=n           | 提升年老代的最大临界值(tenuring threshold). 默认值为 15.     |                        |


# CMS
CMS（Concurrent Markup Sweep Collector）
## 停顿次数
CMS停顿两次,但是停顿较长
1. 初始标记(CMS-initial-mark) 暂停
2. 并发标记(CMS-concurrent-mark)
3. 重新标记(CMS-remark) 暂停
4. 并发清除(CMS-concurrent-sweep)
5. 并发重设状态等待下次CMS的触发(CMS-concurrent-reset)

## 解决碎片
Mixed GC时移动碎片，统一回收

## 执行步骤
CMS(Concurrent Mark-Sweep)(并发 标记-清除)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。
1. 初始标记 (Stop the World事件 CPU停顿， 很短) ，初始标记采用可达性分析，仅标记一下GC Roots能直接关联到的对象，速度很快。
2. 并发标记 (收集垃圾跟用户线程一起执行) 初始标记和重新标记任然需要“stop the world”，并发标记过程就是进行GC Roots Tracing的过程；
3. 重新标记 (Stop the World事件 CPU停顿，比初始标记稍微长，远比并发标记短)修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短
4. 并发清理 -清除算法；

整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 
**优点**
允许垃圾收集线程和应用线程并行执行。相对于Parallel 不用在标记垃圾的时候Stop World，只需要在清理垃圾的时候Stop World。
**缺点**
串行收集器、并行收集器和并发标记清除收集器等共有的缺点
1. 只能针对老年代
2. 所有针对老年代的操作必须扫描整个老年代空间
3. 新生代和老年代是独立的连续的内存块，必须先决定年轻代和老年代在虚拟地址空间的位置
4. 并发标记垃圾，但是清除垃圾还是需要Stop World

**CMS参数**

| 参数                                  | 作用         |      |
| ------------------------------------- | ------------ | ---- |
| -XX:+UseParNewGC                      | 使用ParNewGC |      |
| -XX:+UseConcMarkSweepGC               | 使用CMSGC    |      |
| -XX:CMSInitiatingOccupancyFraction=70 |              |      |
| -XX:+CMSParallelRemarkEnabled         |              |      |

## ZGC
以上垃圾回收期都是HotSpot（oracle jvm官方团队的产品），ZGC是JDK11推出的产品，支持海量吞吐（最大4T），不在学习范围内