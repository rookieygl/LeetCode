# 搜索架构
## 搜索流程
分词，召回，排序
## 索引预排序

## ES错误回滚

# 语言
## GO
1. 协程的实现
2. 切片和数组
3. channel
4. go内存模型
## Python
1. 全局锁
2. 协程优化


## 对比协程和线程池


# 中间件
## Redis
### 事件
1. 文件事件： 读事件，写事件
2. 时间事件： 定时事件，周期性事件 

## Redis 为什么阻塞
### 性能阻塞
1. 一旦某个客户端的某个命令执行时间很长，就会阻塞其他客户端
2. reactor模型是同步IO，需要等待命令执行完成，才会返回结果，
    然后进入下一次执行过程 （队列）
3. cpu饱和
4. 内存饱和
### 带宽阻塞
流量跑满
### 线程阻塞
redis采用单线程处理请求
## 分布式锁
服务串行执行
###  令牌桶
### Redis 锁冲突
1. set
    缺点：没有原子性。高并发情况下，进程同时获取锁状态为null，同时设置，锁之间相互覆盖，
    但是俩进程仍在并发执行业务代码
>set(lock,1);
>jedis.del(lock)
当进程执行出现问题，锁未释放，则其他进程永远处于阻塞状态，出现死锁
2. setnx
    setnx的原子操作命令，锁存在不能设置值，返回0；锁不存在，则设置锁，返回1；
    缺点：当进程执行出现问题，锁未释放，则其他进程永远处于阻塞状态，出现死锁
>jedis.setnx(lock, 1)
3. setnx+getset
    为解决上面的问题，可以使用getset命令，getset设置键值，并返回原来的键值。
    加锁：setnx(lock, 时间戳+超时时间)
    续命
```yaml
while(jedis.setnx(lock, now+超时时间)==0）{
    if(now>jedis.get(lock) && now>jedis.getset(lock, now+超时时间)){
        break;
    }else{
        Thread.sleep(300);
    }
}
# 执行业务代码;
jedis.del(lock);
```

