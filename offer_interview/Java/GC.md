# 垃圾回收
## Young GC和Full GC
Young GC只针对新生代，老年代是Full GC，也叫Major GC。

### Young GC
新生代分为：Eden，Survivor （Survivor0，Survivor1），Eden是最大的区域，因此有个针对Eden的回收过程，称为Minor GC。

Young GC是在新生代的Eden区域满了之后就会触发，数据量较小，一般采用复制算法来回收新生代的垃圾
**停止-复制（Stop-and-copy）清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中）**

**Young GC回收过程**
Young GC一直在运行，大部分对象创建后，很快不再使用。Eden满了，也会触发Young GC，大对象会被直接创建在老年代。

- 绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快。
- 最初一次，当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）；
- 下次Eden区满了，再执行一次Minor GC，将消亡的对象清理掉，将存活的对象复制到Survivor1中，然后清空Eden区；
- 将Survivor0中消亡的对象清理掉，**将其中可以晋级的对象晋级到Old区**，将存活的对象也复制到Survivor1区，然后清空Survivor0区；
- 当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。



### Full GC
Full GC又叫Major GC

- 发生Young GC之前进行检查，**如果老年代可用的连续内存空间`< `Young GC后升入老年代的对象总和的平均大小，**说明本次Young GC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间，此时必须先触发一次Old GC给老年代腾出更多的空间，然后再执行Young GC。
- 老年代内存使用率超过了92%，也要直接触发Old GC，当然这个比例是可以通过参数调整的。

概括成一句话，就是老年代空间也不够了，没法放入更多对象了，这个时候务必执行Old GC对老年代进行垃圾回收。



## 标记垃圾
hotspot（oracle 官方虚拟机，gc默认为可达算法）
### 引用计数法
被引用一次，计数器加1，为0标记为垃圾。无法解决循环依赖。两个空对象互相引用，计数都为1，导致无法回收。
### 可达性分析
从root对象开始寻找引用链，不在引用链的标记为垃圾。

可以作为root节点的对象有：

- 虚拟机栈中引用的对象（栈帧中的本地变量表）；

- 方法区中类静态属性引用的对象；根据这条规则，单例也可以作为根对象。

- 方法区中常量引用的对象；

- 本地方法栈中JNI（Native方法）引用的对象。

### 三色标记

g1，zgc有所应用，了解即可。白，灰，黑确认三种对象类型。

并发标记会有遗漏。



## 垃圾清除算法

只有这三种算法，各有优缺点，垃圾回收器会采用多个清除算法进行工作。

- 复制算法：复制到另一端，需要双倍内存。适合内存小的区域（新生代）
- 标记清除：空间不连续。
- 标记整理：最优解。标记后移动到一端，整理内存后清理。



# 垃圾回收器

- Serial/Serial Old：单线程垃圾回收器。会Stop World
- Parallel Scavenge/Parallel Old:并行垃圾回收器。Stop World时间比单线程较短。
- ParNew/CMS:cms垃圾回收器，并行标记，Stop World清除垃圾。比Parallel 暂停较短。

以上的jdk1.7之前的垃圾回收器，都需要配置JVM，针对新生代和老年代组合使用。效率不高，推荐使用最新的垃圾回收器。

**JDK 7u4推出G1，Java 11推出ZGC**

- G1（Garbage First）：逻辑分区，物理不分区，追求停顿时间。
- ZGC：逻辑不分区，物理不分区。



## CMS

**执行步骤**

CMS(Concurrent Mark-Sweep)(并发 标记-清除)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。

- 初始标记 (Stop the World事件 CPU停顿， 很短) ，初始标记采用可达性分析，仅标记一下GC Roots能直接关联到的对象，速度很快。
- 并发标记 (收集垃圾跟用户线程一起执行) 初始标记和重新标记任然需要“stop the world”，并发标记过程就是进行GC Roots Tracing的过程；
- 重新标记 (Stop the World事件 CPU停顿，比初始标记稍微长，远比并发标记短)修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短
- 并发清理 -清除算法；

整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 

**优点**

允许垃圾收集线程和应用线程并行执行。相对于Parallel 不用在标记垃圾的时候Stop World，只需要在清理垃圾的时候Stop World。

**缺点**

串行收集器、并行收集器和并发标记清除收集器（cms[current-mark-sweep]）等共有的缺点

- 只能针对老年代
- 所有针对老年代的操作必须扫描整个老年代空间
- 新生代和老年代是独立的连续的内存块，必须先决定年轻代和老年代在虚拟地址空间的位置
- 并发标记垃圾，但是清除垃圾还是需要Stop World



除了G1和ZGC，旧版的GC回收器都需要组合使用

**CMS参数**

| 参数                                  | 作用         |      |
| ------------------------------------- | ------------ | ---- |
| -XX:+UseParNewGC                      | 使用ParNewGC |      |
| -XX:+UseConcMarkSweepGC               | 使用CMSGC    |      |
| -XX:CMSInitiatingOccupancyFraction=70 |              |      |
| -XX:+CMSParallelRemarkEnabled         |              |      |



## G1

G1是一种服务端应用使用的压缩垃圾收集器，目标是用在多核、大内存的机器上，它在大多数情况下可以实现指定的GC暂停时间，同时还能保持较高的吞吐量。

**实现原理**

- 分区（Region）

  依旧有老年代和新生代，不过被分散在棋盘格式的相等的内存块里。每个分区都可能是年轻代也可能是老年代，但是在同一时刻只能属于某个代。也就是逻辑分区，物理不分区。

  Region大小一致，数值是在 1M 到 32M 字节之间的一个 2 的幂值数，JVM 会尽量划分 2048 个左右、同等大小的 region。当然这个数字既可以手动调整，G1 也会根据堆大小自动进行调整。

- 收集集合（CSet）

  一组可被回收的分区的集合。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区可以来自Eden空间、survivor空间、或者老年代。CSet会占用不到整个堆空间的1%大小。

- 已记忆集合（RSet）

  RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。RSet的价值在于使得垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。

- Snapshot-At-The-Beginning(SATB)

**执行步骤**

-  Concurrent Global Marking： 并发扫描一遍之后，G1知道了哪些Region里大部分是空的（即大部分是可回收的对象），G1把收集和压缩操作集中于此，放进CSet，因此得名Garbage First

- Evacuation. 并发地将一个或多个Region的资源拷贝至新的Region，压缩内存、拷贝、释放已拷贝完成的Region。与此相比，CMS没有压缩内存（去除碎片）这一步，ParallelOld垃圾收集只进行全堆压缩.

**优点**

- Eden、Survivor、Old区不再固定，在内存使用效率上来说更灵活，减少磁盘碎片。

  假若通过 -Xmn 显式地指定了年轻代的大小, 则会干扰到 G1收集器的默认行为.

- G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间，避免应用雪崩现象。

- G1在回收内存后会马上同时做合并空闲内存的工作，而CMS默认是在STW(stop the world)的时候做。

- G1会在young GC中使用，而CMS只能在老年代中使用。

- G1是棋盘格局，**标记-整理**方式清除垃圾，压缩空间方面有优势。



**缺点**

- Region棋盘格局导致大小对象占用的格子是一样的，导致空间分配不均匀，并且，region 太小不合适，会令你在分配大对象时更难找到连续空间。



 **G1核心参数**

| 参数名称                             | 含义                                                         | 默认值                 |
| ------------------------------------ | ------------------------------------------------------------ | ---------------------- |
| -XX:+UseG1GC                         | 开启G1垃圾收集器                                             |                        |
| -XX:MaxGCPauseMillis=200             | 设置期望达到的最大GC停顿时间指标（毫秒单位，JVM会尽力实现，但不保证达到），值越低，cpu占用率越高。 | 200                    |
| XX:InitiatingHeapOccupancyPercent=45 | 堆内存占用百分比.，G1用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比. 值为0，表示一直gc | 45                     |
| -XX:NewRatio=n                       | 新生代与老生代的大小比例，不允许值小于1，即Old要比Yong大     | 2：新生代：老年代：1:2 |
| -XX:MaxTenuringThreshold=n           | 提升年老代的最大临界值(tenuring threshold). 默认值为 15.     |                        |

## ZGC
以上垃圾回收期都是HotSpot（oracle jvm官方团队的产品），ZGC是JDK11推出的产品，支持海量吞吐（最大4T），不在学习范围内。