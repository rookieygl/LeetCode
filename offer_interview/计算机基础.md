# 计算机基础
## 单位
1. bit
    这是计算机的最小单位，二进制一位就是一bit
2. byte：8bit
    英文字母、阿拉伯数字是1bit，中文2个bit
3. kb：1kb=1024byte
    1kb有512个中文字符，1024个英文字符

# RAM和ROM
## ROM（Read-Only Memory）
磁盘
## RAM（Random Access Memory）随机存取存储器
内存，一种是静态RAM：SRAM；一种是动态RAM：DRAM。前者的存储速度要比后者快得多
1. 静态随机存储器(SRAM)
    读取速度快，集成度低（存储相同的数据，静态RAM的体积是动态RAM的6倍），价格高
    我们现在使用的内存一般都是动态RAM
2. 动态随机存储器(DRAM)

# 网路基础
## 五层网络
### TCP/IP
**TCP(Transmission Control Protocol) 传输控制协议**
**IP(Internet Protocol Address)  互联网协议地址**

### 三次握手
完成三次握手，客户端与服务器开始传送数据
1. 第一次握手
  建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。
2. 第二次握手
  服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。
3. 第三次握手
  客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。




### 四次断开
1. 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 
2. 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 
3. 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 
4. 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 
简单说来是 “先关读，后关写”，一共需要四个阶段。以客户机发起关闭连接为例：
1. 服务器读通道关闭
2. 客户机写通道关闭
3. 客户机读通道关闭
4. 服务器写通道关闭
### 连接状态
先有CLOSE_WAIT，后有TIME_WAIT
#### CLOSE_WAIT
被动关闭
1. 发起TCP连接关闭的一方称为client，被动关闭的一方称为server。
2. 被动关闭的server收到FIN后，但未发出ACK，导致端口占用。出现这种状况一般都是由于server端代码的问题，应该要考虑检查代码。

#### SYN_SEND
客户端尝试链接服务端
#### SYN_RECEIVED
服务接受创建请求的SYN后，也就是TCP三次握手中的第2步
#### ESTABLISHED 
正在通信
#### TIME_WAIT
主动关闭
1. TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，即4分钟。主要是防止最后一个ACK丢失。
2. TIME_WAIT状态下的socket不能被回收使用，浪费端口。
    具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接，将导致服务器端存在大量的处于TIME_WAIT状态的socket， 
    甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力，甚至耗尽可用的socket，停止服务	

解决方法
1. server端应尽量减少主动关闭连接
2. 修改linux配置，加快端口回收。

#### 查看服务器的连接状态
```shell
netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'  
```

### https和http
https如何让保证数据安全

1. 对称加密
  用密码加密，加密和解密都用同一把密钥。风险很大。
2. 非对称加密
  1 公钥：在网络中传输
  2. 私钥：在客户端保存
  用公钥加密的数据，只有对应的私钥才能解密；用私钥加密的数据，只有对应的公钥才能解密。
  风险存在于公钥被截取，套用自己的公钥获取客户端私钥密文，再用自己的私钥篡改密文，反过来也一样。
3. 数字证书CA
  证明这把公钥是唯一的策略。
  将公钥以及服务器的个人信息通过Hash算法生成**信息摘要**，根据CA提供的私钥对信息摘要进行加密来形成**数字签名**，
  最后还会把原来没Hash算法之前的个人信息以及公钥和数字签名合并在一起，形成**数字证书**
  当客户端拿到这份数字证书之后，就会用CA提供的公钥来对数字证书里面的数字签名进行解密来得到信息摘要，
  然后对数字证书里服务器的公钥以及个人信息进行Hash得到**另外一份信息摘要**。最后把**两份信息摘要进行对比**。
  因此客户端需要存一个CA证书。
  
# Nginx
1. 正向代理
2. 反向代理

